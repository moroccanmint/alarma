<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALARMA</title>
    <link rel="apple-touch-icon" sizes="57x57" href="icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.css" />
    <link rel="stylesheet" href="./css/styles.css">  
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
    
    <!-- Add Firebase SDKs before your other scripts -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    
    <!-- Initialize Firebase -->
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBgH6ZJ1KgMkitKcL7YnigNm1r1P_Dr5Rs",
            authDomain: "alarma-5c1e2.firebaseapp.com",
            projectId: "alarma-5c1e2",
            storageBucket: "alarma-5c1e2.firebasestorage.app",
            messagingSenderId: "941557402373",
            appId: "1:941557402373:web:4ea380076722da1620056c",
            measurementId: "G-7CM36MZG1K"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
    </script>
</head>

<body>
    <button id="toggle-sidebar"><img id="menu" src="./menu.svg"></button>
    <div id="sidebar">
        <div id="sidebar-header">
            <img id="logo" src="./alarma-logo-text.svg" alt="ALARMA Logo">
        </div>
        <div id="station-container">
            <!-- Station cards will be dynamically inserted here -->
        </div>
        <div id="user-info">
            <p id="phone-display">An SMS alert will be sent to your registered phone number: <span id="user-phone">Loading...</span></p>
            <button id="logout-btn">Logout</button>
        </div>
    </div>
    <div id="map-container">
        <div id="map"></div>
        <div id="bottom-dock">
            <button id="pin-destination-btn" class="dock-btn"><img src="./pin.svg"><span class="button-descriptions">Pin Destination</span></button>
            <button id="route-btn" class="dock-btn warning"><img src="./route.svg"><span class="button-descriptions">Find Safe Route</span></button>
            <button id="about-btn" class="dock-btn" onclick="window.open('./about.html', '_blank')"><img src="./about.svg"><span class="button-descriptions">About Alarma</span></button>
        </div>
        <div id="transport-toggle">
            <button id="car-mode" class="transport-btn active"><img src="./car.svg">Car</button>
            <button id="bike-mode" class="transport-btn"><img src="./motorcycle.svg">Motorcycle</button>
        </div>
    </div>
    <div id="loading-overlay">
        <div class="spinner">
            <img src="./icons/alarma-logo.png" alt="Loading...">
        </div>
    </div>
    <div class="station-controls" id="station-controls">
        <!-- Station toggle buttons will be added here dynamically -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.min.js"></script>
    <script>
        // Toggle sidebar functionality
        const toggleBtn = document.getElementById('toggle-sidebar');
        const sidebar = document.getElementById('sidebar');

        toggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('active');
        });

        // Close sidebar when clicking outside
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 1100) {  // Only on mobile view
                const isClickInsideSidebar = sidebar.contains(e.target);
                const isClickOnToggleBtn = toggleBtn.contains(e.target);
                
                if (!isClickInsideSidebar && !isClickOnToggleBtn && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                }
            }
        });

        // Initialize stations data
        const stations = [
            {
                id: 'station-1',
                name: 'Alarma Station 1',
                coordinates: [15.024505, 120.680464],
                status: 'normal',
                lastUpdate: new Date().toISOString(),
                visible: true
            },
            {
                id: 'station-2',
                name: 'Alarma Station 2',
                coordinates: [15.030505, 120.685464],
                status: 'normal',
                lastUpdate: new Date().toISOString(),
                visible: true
            },
            {
                id: 'station-3',
                name: 'Alarma Station 3',
                coordinates: [15.028505, 120.682464],
                status: 'normal',
                lastUpdate: new Date().toISOString(),
                visible: true
            },
            // Add invisible expressway stations
            {
                id: 'nlex-1',
                name: 'NLEX Del Carmen',
                coordinates: [15.067154, 120.682260],
                status: 'normal',
                lastUpdate: new Date().toISOString(),
                visible: false
            },
            {
                id: 'nlex-2',
                name: 'NLEX Jose Abad Santos',
                coordinates: [15.049260, 120.694826],
                status: 'normal',
                lastUpdate: new Date().toISOString(),
                visible: false
            },
        ];

        // Update icon configurations
        const startIcon = L.icon({
            iconUrl: './start.svg',
            iconSize: [36, 36],
            iconAnchor: [18, 36],
            popupAnchor: [0, -36]
        });

        const endIcon = L.icon({
            iconUrl: './end.svg',
            iconSize: [36, 36],
            iconAnchor: [18, 36],
            popupAnchor: [0, -36]
        });

        // Update station icons as well for consistency
        const stationIcons = {
            normal: L.icon({
                iconUrl: './station3.svg',
                iconSize: [48, 48],
                iconAnchor: [24, 24],
                popupAnchor: [0, -24]
            }),
            warning: L.icon({
                iconUrl: './warning.svg',
                iconSize: [48, 48],
                iconAnchor: [24, 24],
                popupAnchor: [0, -24]
            }),
            emergency: L.icon({
                iconUrl: './flooded.svg',
                iconSize: [48, 48],
                iconAnchor: [24, 24],
                popupAnchor: [0, -24]
            })
        };

        // Initialize map
        const map = L.map('map').setView([15.024505, 120.680464], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Station markers
        const markers = new Map();
        let startMarker, endMarker;
        let routingControl = null;
        let transportMode = 'driving'; // Default mode

        // Initialize stations on map
        function initializeStations() {
            stations.forEach(station => {
                if (station.visible) {
                    const marker = L.marker(station.coordinates, {
                        icon: stationIcons[station.status],
                        title: station.name
                    }).addTo(map);

                    marker.bindPopup(`<b>${station.name}</b><br>Status: ${station.status}`);
                    markers.set(station.id, marker);
                }
            });
            updateStatusPanel();
        }

        function updateStatusPanel(updatedStationId = null) {
            const stationContainer = document.getElementById('station-container');
            stationContainer.innerHTML = stations
                .filter(station => station.visible) // Only include visible stations
                .map(station => {
                    // Format the date properly, handling potential invalid dates
                    let formattedDate = 'Unknown';
                    try {
                        // Check if lastUpdate is a Firebase Timestamp or a string
                        if (station.lastUpdate && typeof station.lastUpdate.toDate === 'function') {
                            // It's a Firebase Timestamp
                            formattedDate = station.lastUpdate.toDate().toLocaleString();
                        } else if (station.lastUpdate) {
                            // It's a string or another format
                            formattedDate = new Date(station.lastUpdate).toLocaleString();
                        }
                    } catch (e) {
                        console.error('Error formatting date:', e);
                    }
                    
                    return `
                        <div class="station-card ${updatedStationId === station.id ? 'station-update-animation' : ''}" data-station-id="${station.id}">
                            <h3>${station.name}</h3>
                            <div class="station-status status-${station.status}">
                                ${station.status.charAt(0).toUpperCase() + station.status.slice(1)}
                            </div>
                            <p class="station-timestamp">Last Update: ${formattedDate}</p>
                        </div>
                    `;
                }).join('');

            // Add click event listeners to station cards
            const stationCards = document.querySelectorAll('.station-card');
            stationCards.forEach(card => {
                card.addEventListener('click', () => {
                    const stationId = card.dataset.stationId;
                    const station = stations.find(s => s.id === stationId);
                    if (station) {
                        map.setView(station.coordinates, 15); // Zoom level 15 for closer view
                        markers.get(stationId).openPopup();
                    }
                });
                
                // Add hover style to indicate clickability
                card.style.cursor = 'pointer';
            });
        }

        // Routing functions
        async function tryRoute(waypoints) {
            const waypointStr = waypoints.map(w => `${w.lng},${w.lat}`).join(';');
            try {
                const response = await fetch(`https://router.project-osrm.org/route/v1/${transportMode}/${waypointStr}?overview=full&geometries=geojson`);
                if (!response.ok) throw new Error('Failed to fetch route');

                const data = await response.json();
                if (!data.routes || data.routes.length === 0) throw new Error('No route found');

                const coordinates = data.routes[0].geometry.coordinates;
                const route = coordinates.map(coord => L.latLng(coord[1], coord[0]));

                if (isRouteCrossingFloodedArea(route)) {
                    return { success: false };
                }

                return {
                    success: true,
                    route,
                    distance: data.routes[0].distance,
                    duration: data.routes[0].duration
                };
            } catch (err) {
                console.error('Route attempt failed:', err);
                return { success: false };
            }
        }

        function isRouteCrossingFloodedArea(route) {
            return stations.some(station => {
                if (station.status !== 'normal') {
                    return route.some(point => {
                        const distance = map.distance(point, L.latLng(station.coordinates));
                        return distance < 250; // 250 meters radius around flooded stations
                    });
                }
                return false;
            });
        }

        async function findSafeRoute(start, end) {
            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }

            document.getElementById('loading-overlay').style.display = 'flex';

            // Try direct route first
            const directResult = await tryRoute([start, end]);
            if (directResult.success) {
                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(start.lat, start.lng),
                        L.latLng(end.lat, end.lng)
                    ],
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://router.project-osrm.org/route/v1',
                        profile: transportMode,
                        numberOfAlternatives: 2 // Show up to 2 alternative routes
                    }),
                    lineOptions: {
                        styles: [{ color: '#000000', weight: 4 }],
                        extendToWaypoints: true,
                        missingRouteTolerance: 0
                    },
                    altLineOptions: {
                        styles: [
                            { color: '#777777', weight: 4, opacity: 0.6 },
                            { color: '#999999', weight: 4, opacity: 0.4 }
                        ]
                    },
                    addWaypoints: false,
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    showAlternatives: true,
                    createMarker: function () { return null; },
                    containerClassName: 'routing-container'
                }).addTo(map);

                document.getElementById('loading-overlay').style.display = 'none';
                return;
            }

            // Try finding alternative routes
            const floodedStations = stations.filter(s => s.status !== 'normal');
            const radiusStep = 0.005; // roughly 500 meters
            const maxRadius = 0.05; // roughly 5km

            for (let radius = radiusStep; radius <= maxRadius; radius += radiusStep) {
                for (const station of floodedStations) {
                    const angles = Array.from({ length: 36 }, (_, i) => i * 10); // Try 36 directions

                    for (const angle of angles) {
                        const lat = station.coordinates[0] + radius * Math.cos(angle * Math.PI / 180);
                        const lng = station.coordinates[1] + radius * Math.sin(angle * Math.PI / 180);
                        const waypoint = L.latLng(lat, lng);

                        const alternativeResult = await tryRoute([start, waypoint, end]);
                        if (alternativeResult.success) {
                            routingControl = L.Routing.control({
                                waypoints: [
                                    L.latLng(start.lat, start.lng),
                                    waypoint,
                                    L.latLng(end.lat, end.lng)
                                ],
                                router: L.Routing.osrmv1({
                                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                                    profile: transportMode
                                }),
                                lineOptions: {
                                    styles: [{ color: '#000000', weight: 4 }]
                                },
                                addWaypoints: false,
                                draggableWaypoints: false,
                                fitSelectedRoutes: true,
                                createMarker: function () { return null; }
                            }).addTo(map);

                            document.getElementById('loading-overlay').style.display = 'none';
                            return;
                        }
                    }
                }
            }

            document.getElementById('loading-overlay').style.display = 'none';
            alert('Unable to find a safe route. All possible routes cross flooded areas.');
        }

        // Add this function to listen for station updates using Firebase
        function setupStationListeners() {
            console.log("Setting up station listeners");
            
            // Remove the polling interval if it exists
            if (window.stationUpdateInterval) {
                clearInterval(window.stationUpdateInterval);
                console.log("Cleared existing polling interval");
            }
            
            // Log the Firestore instance to verify it's initialized properly
            console.log("Firestore instance:", db);
            
            // Log all stations we're trying to listen to
            console.log("Stations to monitor:", stations);
            
            // Set up a real-time listener for each station
            stations.forEach(station => {
                // Use the station ID directly
                const stationId = station.id; // This will be 'station-1', 'station-2', etc.
                
                console.log(`Setting up listener for ${stationId}`);
                
                // Create a reference to the station document using the exact ID
                const stationRef = db.collection('stations').doc(stationId);
                console.log(`Created reference to document: stations/${stationId}`);
                
                try {
                    // Set up the real-time listener with detailed logging
                    const unsubscribe = stationRef.onSnapshot((doc) => {
                        console.log(`Snapshot received for ${stationId}:`, doc);
                        
                        if (doc.exists) {
                            console.log(`Document exists for ${stationId}`);
                            const stationData = doc.data();
                            console.log(`Data for ${stationId}:`, stationData);
                            
                            // Check if the document has the expected fields
                            if (stationData.status === undefined) {
                                console.warn(`Document for ${stationId} is missing 'status' field`);
                            }
                            if (stationData.lastUpdate === undefined) {
                                console.warn(`Document for ${stationId} is missing 'lastUpdate' field`);
                            }
                            
                            // Check if status has changed
                            const oldStatus = station.status;
                            const newStatus = stationData.status || station.status;
                            
                            // Update local station data
                            station.status = newStatus;
                            station.lastUpdate = stationData.lastUpdate || station.lastUpdate;
                            console.log(`Updated local station data for ${stationId}:`, station);
                            
                            // Show alert banner if status changed to warning or emergency
                            if (oldStatus !== newStatus && newStatus !== 'normal') {
                                const alert = document.createElement('div');
                                alert.className = `alert-banner ${station.status}`;
                                
                                alert.innerHTML = `
                                    <div class="alert-content">
                                        <div class="alert-icon">${station.status === 'warning' ? 'â ï¸' : 'ð¨'}</div>
                                        <div class="alert-message">
                                            <strong>${station.name}</strong> reporting ${station.status} status!
                                        </div>
                                    </div>
                                    <button class="alert-close">Ã</button>
                                `;

                                document.body.appendChild(alert);
                                
                                // Add click handler for close button
                                const closeBtn = alert.querySelector('.alert-close');
                                if (closeBtn) {
                                    closeBtn.addEventListener('click', () => {
                                        alert.classList.add('alert-closing');
                                        setTimeout(() => {
                                            if (alert && alert.parentNode) {
                                                alert.remove();
                                            }
                                        }, 300);
                                    });
                                }
                                
                                // Remove the alert after 5 seconds
                                setTimeout(() => {
                                    if (alert && alert.parentNode) {
                                        alert.classList.add('alert-closing');
                                        setTimeout(() => alert.remove(), 300);
                                    }
                                }, 5000);
                            }
                            
                            // Update marker with animation
                            const marker = markers.get(station.id);
                            if (marker) {
                                console.log(`Updating marker for ${stationId}`);
                                
                                // Add pulse animation to marker
                                const markerElement = marker.getElement();
                                if (markerElement) {
                                    // Remove any existing animation class first
                                    markerElement.classList.remove('pulse-animation');
                                    // Force reflow to restart animation
                                    void markerElement.offsetWidth;
                                    // Add animation class
                                    markerElement.classList.add('pulse-animation');
                                    setTimeout(() => markerElement.classList.remove('pulse-animation'), 1500);
                                }
                                
                                marker.setIcon(stationIcons[station.status]);
                                marker.getPopup().setContent(`<b>${station.name}</b><br>Status: ${station.status}`);
                            } else {
                                console.warn(`No marker found for ${stationId}`);
                            }
                            
                            // Update flood circles with centered animation
                            console.log(`Updating flood circles for ${stationId}`);
                            
                            // Remove existing flood circles for this station
                            map.eachLayer((layer) => {
                                if (layer instanceof L.Circle && 
                                    layer.getLatLng().lat === station.coordinates[0] && 
                                    layer.getLatLng().lng === station.coordinates[1]) {
                                    map.removeLayer(layer);
                                }
                            });
                            
                            // Add new flood circle if status is not normal
                            if (station.status !== 'normal') {
                                // Create the circle with proper styling
                                const circle = L.circle(station.coordinates, {
                                    color: station.status === 'warning' ? 'orange' : 'red',
                                    fillColor: station.status === 'warning' ? '#ff9800' : '#f03',
                                    fillOpacity: 0.5,
                                    radius: 250
                                }).addTo(map);
                                
                                // Get the SVG element of the circle and add animation class
                                setTimeout(() => {
                                    const circleElement = circle.getElement();
                                    if (circleElement) {
                                        // Find the path element inside the SVG
                                        const pathElement = circleElement.querySelector('path');
                                        if (pathElement) {
                                            pathElement.classList.add('pulse-animation');
                                            setTimeout(() => pathElement.classList.remove('pulse-animation'), 1500);
                                        }
                                    }
                                }, 10); // Small delay to ensure the element is in the DOM
                            }
                            
                            // Update the UI with animation
                            updateStatusPanel(stationId);
                            updateStationControls();
                        } else {
                            console.warn(`No document exists for ${stationId}`);
                        }
                    }, (error) => {
                        console.error(`Error listening to ${stationId}:`, error);
                    });
                    
                    console.log(`Successfully set up listener for ${stationId}`);
                    
                    // Store the unsubscribe function to clean up later if needed
                    if (!window.firestoreUnsubscribes) {
                        window.firestoreUnsubscribes = {};
                    }
                    window.firestoreUnsubscribes[stationId] = unsubscribe;
                    
                } catch (error) {
                    console.error(`Exception setting up listener for ${stationId}:`, error);
                }
            });
            
            // Test query to verify Firestore access
            console.log("Testing Firestore access with a simple query...");
            db.collection('stations').get()
                .then(snapshot => {
                    console.log("Firestore test query successful. Documents found:", snapshot.size);
                    snapshot.forEach(doc => {
                        console.log("Test query document:", doc.id, doc.data());
                    });
                })
                .catch(error => {
                    console.error("Firestore test query failed:", error);
                });
        }

        // Get user location
        function getUserLocation() {
            document.getElementById('loading-overlay').style.display = 'flex';
            
            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            };

            navigator.geolocation.getCurrentPosition(
                position => {
                    const { latitude, longitude } = position.coords;
                    startMarker = L.marker([latitude, longitude], { 
                        draggable: true,
                        icon: startIcon
                    })
                        .addTo(map)
                        .bindPopup("Current Location")
                        .openPopup();
                    map.setView([latitude, longitude], 13);
                    document.getElementById('loading-overlay').style.display = 'none';
                }, 
                error => {
                    console.error("Geolocation failed:", error);
                    let errorMessage = "Unable to access your location. ";
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += "Please enable location services in your browser settings.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += "Location information is unavailable.";
                            break;
                        case error.TIMEOUT:
                            errorMessage += "Location request timed out.";
                            break;
                        default:
                            errorMessage += "Using default location.";
                    }

                    const fallbackCoords = [15.024505, 120.680464];
                    startMarker = L.marker(fallbackCoords, { 
                        draggable: true,
                        icon: startIcon
                    })
                        .addTo(map)
                        .bindPopup("Fallback Location")
                        .openPopup();
                    map.setView(fallbackCoords, 13);
                    document.getElementById('loading-overlay').style.display = 'none';
                    alert(errorMessage);
                },
                options
            );
        }

        // Call getUserLocation after Firebase authentication
        document.addEventListener('DOMContentLoaded', () => {
            firebase.auth().onAuthStateChanged((user) => {
                if (!user) {
                    window.location.href = './signup.html';
                    return;
                }
                
                // Fetch user data from Firestore to get the phone number
                db.collection('users').doc(user.uid).get()
                    .then((doc) => {
                        if (doc.exists) {
                            const userData = doc.data();
                            const phoneSpan = document.getElementById('user-phone');
                            phoneSpan.textContent = userData.phoneNumber || 'Not available';
                        }
                    })
                    .catch((error) => {
                        console.error('Error fetching user data:', error);
                        const phoneSpan = document.getElementById('user-phone');
                        phoneSpan.textContent = 'Error loading phone number';
                    });

                user.getIdToken().then(token => {
                    window.authToken = token;
                    initializeStations();
                    updateStationControls();
                    getUserLocation(); // Call after authentication
                    setupStationListeners(); // Replace setInterval with real-time listeners
                });
            });

            // Add logout button handler
            document.getElementById('logout-btn').addEventListener('click', () => {
                firebase.auth().signOut().then(() => {
                    // Redirect to signup page after successful logout
                    window.location.href = './signup.html';
                }).catch((error) => {
                    console.error('Error signing out:', error);
                    alert('Error signing out. Please try again.');
                });
            });
        });

        // Modify updateStationStatus to include better error handling
        async function updateStationStatus(stationId) {
            const station = stations.find(s => s.id === stationId);
            if (!station) return;

            // Convert station ID and status to numbers
            const stationNum = parseInt(stationId.split('-')[1]) - 1; // station-1 becomes 0
            const statusNum = station.status === 'normal' ? 0 : 
                             station.status === 'warning' ? 1 : 2;

            try {
                console.log('Sending update to server:', {
                    station: stationNum,
                    status: statusNum
                });

                const API_URL = window.location.hostname === 'localhost' 
                    ? 'http://localhost:5501'
                    : 'https://your-backend-domain.onrender.com';
                const response = await fetch(`${API_URL}/update-station?s=${stationNum}&st=${statusNum}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Server response:', data);
                
                if (!data.success) {
                    throw new Error(data.message || 'Update failed');
                }

                // Update UI immediately after successful server update
                updateStatusPanel();
                updateStationControls();
                
            } catch (error) {
                console.error('Failed to update station status:', error);
                alert('Failed to update station status. Please try again.');
            }
        }

        

        function updateStationControls() {
            const controlsContainer = document.getElementById('station-controls');
            controlsContainer.innerHTML = `
                <button class="close-btn">Ã</button>
                ${stations.map(station => `
                    <button 
                        class="station-toggle-btn ${station.status !== 'normal' ? station.status : ''}"
                        onclick="toggleStationStatus('${station.id}')"
                    >
                        <span>${station.name}</span>
                        <span class="status-text">${
                            station.status === 'normal' ? 'Normal' : 
                            station.status === 'warning' ? 'Warning' : 
                            'Emergency'
                        }</span>
                    </button>
                `).join('')}
            `;

            // Add click handler for close button
            const closeBtn = controlsContainer.querySelector('.close-btn');
            closeBtn.addEventListener('click', () => {
                controlsContainer.classList.remove('active');
            });
        }

        // Event Listeners
        document.getElementById('pin-destination-btn').addEventListener('click', () => {
            if (endMarker) {
                alert('Destination already pinned. Drag the marker to adjust.');
                return;
            }

            const center = map.getCenter();
            // Check if destination is in flooded area
            const isInFloodedArea = stations.some(station => {
                if (station.status !== 'normal') {
                    const distance = map.distance(center, L.latLng(station.coordinates));
                    return distance < 250; // 250 meters radius around flooded stations
                }
                return false;
            });

            if (isInFloodedArea) {
                alert('Cannot set destination in a flooded area. Please choose a different location.');
                return;
            }

            endMarker = L.marker(center, { 
                draggable: true,
                icon: endIcon
            })
                .addTo(map)
                .bindPopup("Destination")
                .openPopup();

            // Add dragend event to check new position
            endMarker.on('dragend', function(event) {
                const marker = event.target;
                const position = marker.getLatLng();
                
                const isInFloodedArea = stations.some(station => {
                    if (station.status !== 'normal') {
                        const distance = map.distance(position, L.latLng(station.coordinates));
                        return distance < 250;
                    }
                    return false;
                });

                if (isInFloodedArea) {
                    alert('Cannot place destination in a flooded area. Please choose a different location.');
                    map.removeLayer(marker);
                    endMarker = null;
                }
            });
        });

        document.getElementById('route-btn').addEventListener('click', () => {
            if (!startMarker || !endMarker) {
                alert('Please set both start and destination points.');
                return;
            }

            const endPosition = endMarker.getLatLng();
            const isInFloodedArea = stations.some(station => {
                if (station.status !== 'normal') {
                    const distance = map.distance(endPosition, L.latLng(station.coordinates));
                    return distance < 250;
                }
                return false;
            });

            if (isInFloodedArea) {
                alert('Cannot route to a destination in a flooded area. Please choose a different destination.');
                return;
            }

            findSafeRoute(startMarker.getLatLng(), endMarker.getLatLng());
        });



        // Update transport mode toggle event listeners
        document.getElementById('car-mode').addEventListener('click', () => {
            console.log('Switching to car mode');
            document.getElementById('car-mode').classList.add('active');
            document.getElementById('bike-mode').classList.remove('active');
            transportMode = 'driving';
            
            // Update expressway stations
            updateExpresswayStations('car');
            
            // Recalculate route if one exists
            if (startMarker && endMarker && routingControl) {
                console.log('Recalculating route with driving mode');
                findSafeRoute(startMarker.getLatLng(), endMarker.getLatLng());
            }
        });

        document.getElementById('bike-mode').addEventListener('click', () => {
            console.log('Switching to motorcycle mode');
            document.getElementById('bike-mode').classList.add('active');
            document.getElementById('car-mode').classList.remove('active');
            transportMode = 'bike';
            
            // Update expressway stations
            updateExpresswayStations('bike');
            
            // Recalculate route if one exists
            if (startMarker && endMarker && routingControl) {
                console.log('Recalculating route with cycling mode');
                findSafeRoute(startMarker.getLatLng(), endMarker.getLatLng());
            }
        });

        // Add function to update expressway stations based on transport mode
        function updateExpresswayStations(mode) {
            stations.forEach(station => {
                if (!station.visible) {
                    if (mode === 'bike') {
                        station.status = 'emergency';
                    } else {
                        station.status = 'normal';
                    }
                }
            });
        }
    </script>
</body>

</html>